import React from "react";
import { CLAUDE_CODE_ESSENTIALS_FOUNDATIONS } from "../../../lib/state/blog";
import { BlogImage } from "../../../components/blog-image";
import UltrathinkTerminal from "../../../components/UltrathinkTerminal";
import { CodeBlock } from "../../../components/code-block";
import MdxLayout from "../../../components/mdx-layout";

export const metadata = {
  title: CLAUDE_CODE_ESSENTIALS_FOUNDATIONS.title,
  date: CLAUDE_CODE_ESSENTIALS_FOUNDATIONS.date
};

# {metadata.title}

<div className="series-notice hidden">
  **This is Part 1 of a 3-part series on working effectively with Claude Code.**

  - **#1: Essential foundations and basic workflows**
  - #2: Advanced automation with agents, commands, and hooks
  - #3: Production readiness with TDD and security
</div>

<BlogImage
  src="/claude-code-essentials-foundations/claude-code-essentials.webp"
  caption="Claude Code Essentials: Foundations for Effective AI-Assisted Development"
/>

After months of daily use with Claude Code work and personal projects, I've learned that effectiveness isn't about maximizing AI usage—it's about building the right foundation.

Here are four practices that made the difference for me: they enable faster iteration while keeping quality, security, and maintainability front and center.

1. [Context Specificity](#1-be-specific) - Provide rich, precise input
2. [CLAUDE.md configuration](#2-master-object-object-files) - Teach Claude your codebase once
3. [Plan Mode](#3-use-plan-mode), - Let Claude think before coding
4. [Context Window Management](#4-break-it-down-manage-context) - Keep conversations tight and focused

Getting these four things right is the foundation for what makes Claude Code being an actual force multiplier.

## 1. Be Specific (Use Rich Input)

<BlogImage
  src="/claude-code-essentials-foundations/rich-input.webp"
  caption="Claude Code accepts screenshots, file references via @filepath, piped data, and URLs."
/>

The less specific you are with task-specific details, the more room you give the LLM to make assumptions that rarely match your expectations.

### Example

<CodeBlock language="markdown" wrapLines={true} code={`
❌ Bad: "Build a portfolio website."

✅ Good: "Build me a responsive portfolio website using React 19 and Tailwind CSS v4, with a homepage, about page, and contact form. The design should be Vercel-like brutal minimalism, accessible and minimalist, with a focus on typography and whitespace."`} />

The key difference: be explicit about your specific technology choices, framework versions, and the exact outcomes you expect. Explain what it should look like, how it should behave, and which tools should power it.

### Beyond basic text - provide <em className="font-serif italic">richer</em> context

Depending on the task, supplement your prompt with additional context types:

- **Screenshots**: Drag and drop or paste (<kbd>Cmd</kbd>+<kbd>V</kbd> on macOS, <kbd>Ctrl</kbd>+<kbd>V</kbd> on Windows/Linux) screenshots of designs, error states, or UI issues you want Claude to fix
- **File references**: Use [`@filename` syntax](https://code.claude.com/docs/en/common-workflows#reference-files-and-directories) to reference specific files. Claude gets full context and you can tab-complete filenames
- **Data samples**: [Pipe data directly via stdin](https://code.claude.com/docs/en/headless#streaming-json-input) for analysis: `cat error.log | claude` or `cat data.csv | claude`
- **URLs**: Share documentation URLs for specific libraries or APIs you want Claude to use

After I adopted this structured approach, I went from averaging 3-4 iterations per feature to usually getting it right on the first try.

Being specific in individual prompts is a good and necessary foundation, but having to explain your tech stack every session is neither scalable nor efficient. That's where `CLAUDE.md` comes in.

## 2. Master `CLAUDE.md` Files

<BlogImage
  src="/claude-code-essentials-foundations/master-claude-md.webp"
  caption="Describe your project's architecture, tech stack, conventions, and rules in CLAUDE.md files."
/>

Before I started using `CLAUDE.md`, I was repeatedly explaining our codebase setup & structure, <i className="font-serif">every single session.</i>

### How it works

`CLAUDE.md` files are [loaded hierarchically](https://code.claude.com/docs/en/memory):
1. **Enterprise policy**: `/Library/Application Support/ClaudeCode/CLAUDE.md` (macOS), or `C:\ProgramData\ClaudeCode\CLAUDE.md` (Windows) - organization-wide instructions
2. **Project memory**: `/CLAUDE.md` or `/.claude/CLAUDE.md` - team-shared instructions for the project
3. **User memory**: `~/.claude/CLAUDE.md` - personal preferences for all projects

You can create multiple `CLAUDE.md` files in different subdirectories for focused guidance (e.g., `frontend/CLAUDE.md`, `backend/CLAUDE.md`). You can also reference specific files within `CLAUDE.md` using the `@path/to/import` syntax.

When you start a new Claude Code session, it automatically loads the relevant `CLAUDE.md` files based on your current working directory.

### What to include - An example

<CodeBlock wrapLines={true} collapsible={true} language="markdown" code={`
# Project: Personal Website

## Architecture
  - Next.js 15 app router with TypeScript
  - MDX for blog content

## Tech Stack
  - Framework: Next.js 15, React 19, TypeScript
  - Styling: Tailwind CSS v4
  - Content: MDX with custom components
  - Deployment: Vercel

## Commands
  - \`npm run dev\` - Start development server
  - \`npm run build\` - Build for production
  - \`npm run start\` - Start production server
  - \`npm run lint\` - Run ESLint

  ## Code Conventions
  See @.claude/code-conventions.md for detailed guidelines:
  - TypeScript strict mode, avoid \`any\` types
  - Functional components with hooks
  - Server components by default, client components only when needed
  - Semantic HTML and accessibility-first approach
  - Use \`<BlogImage>\` for images, \`<CodeBlock>\` for code examples
  - MDX layout wrapper required for all blog posts

  ## File Organization
  See @.claude/file-organization.md for structure details:
  - Components: \`/components/[ComponentName].tsx\`
  - Blog posts: \`/app/blog/[slug]/page.mdx\`
  - Utilities: \`/lib/[domain]/[utilName].ts\`
  - Types: Co-located with implementation

  ## Quality Guidelines
  See @.claude/quality-guidelines.md for:
  - Accessibility requirements (WCAG 2.1 AA)
  - Performance budgets
  - SEO best practices
  - Code review checklist

  ## Testing Strategy
  See @.claude/testing.md for:
  - Unit testing approach (if applicable)
  - E2E testing patterns
  - Accessibility testing requirements

  ## Important Rules
  - NEVER commit environment variables or secrets
  - ALWAYS test responsive behavior on mobile/tablet/desktop
  - ALWAYS ensure proper semantic HTML for accessibility
  - Blog post metadata must include title and date
  - Images must have alt text and proper optimization
`} />

### Best practices

1. **Keep it under 100 lines** - Claude loads this every session, and bloat kills signal
2. **Test and refine** - Like production prompts, test effectiveness and remove fluff
3. **Use the `#` key** - During sessions, press `#` to have Claude add new patterns to remember
4. **Version control project files** - Check them into git for team collaboration
5. **Create multiple `CLAUDE.md` files** - Root + subdirectory (`frontend/CLAUDE.md`, `backend/CLAUDE.md`) for focused guidance
6. **Initialize with `/init`** - Claude can generate a starter `CLAUDE.md` for your project

## 3. Use Plan Mode

<BlogImage
  src="/claude-code-essentials-foundations/plan-mode.webp"
  caption="Plan Mode with extended thinking levels—from basic analysis to ultrathink for architectural decisions."
/>

On simple changes like "add a loading spinner while the user data is pending", I'll start straight in `⏵⏵ accept edits on` mode.

But for anything touching multiple files or with potential side effects, I always start with `⏸ plan mode on`

In plan mode, Claude thinks out loud—considers different approaches, flags potential issues, then commits to a strategy before writing a single line.

### How to enter Plan Mode
- Press **Shift+Tab twice** (fastest method)
- Type [`/plan`](https://code.claude.com/docs/en/common-workflows#how-to-use-plan-mode) command
- Include "plan this first" in your request

Sometimes it's helpful to give Claude more thinking capacity with extended thinking levels. These let you control how deeply Claude analyzes the problem before generating code.

### Extended thinking levels

Claude supports different levels of [extended thinking](https://code.claude.com/docs/en/common-workflows#use-extended-thinking) within Plan Mode that help with various complexity levels:

1. **`think`** - Basic analysis, good for straightforward tasks
2. **`think hard`** - Moderate complexity, considers edge cases and alternatives
3. **`think harder`** - Deep analysis for complex problems with multiple constraints
4. <UltrathinkTerminal /> - Maximum depth analysis for architectural decisions, thorough exploration of trade-offs

### When to use Plan Mode (and which thinking level)
- Unclear requirements that need exploration (`think hard`)
- Complex features touching multiple systems (`think hard` or `think harder`)
- Multi-file refactors or architectural changes (`think harder` or <UltrathinkTerminal />)
- Security-sensitive implementations (<UltrathinkTerminal />)
- Architectural decisions affecting multiple systems (<UltrathinkTerminal />)

### How to use extended thinking effectively

<CodeBlock wrapLines={true} language="markdown" code={`
"ultrathink about the best way to implement real-time collaboration in our
React app. Consider WebSockets vs Server-Sent Events vs polling, database
requirements, conflict resolution, and scalability to 10k concurrent users."
`} />

Extended thinking makes Claude explore trade-offs more thoroughly and catch edge cases you might miss in a quick pass.


### Store Plans as Files

For complex features, have Claude save the plan to a markdown file
<CodeBlock wrapLines={true} language="markdown" code={`
"plan the implementation of a role-based access control system and output
the plan to /docs/role-based-access-control-plan.md. Include:
- Overview of roles and permissions
- Required database schema changes
- API endpoint modifications
- Frontend UI updates
- Testing strategy"
`} />

This gives you a reviewable artifact before any code gets written—adjust the approach, add constraints, or refine scope without wasting tokens on implementation.

Once approved, Claude can reference this plan file throughout the session, keeping implementation aligned with the agreed strategy even across multiple `/clear` cycles.

## 4. Break It Down & Manage Context

<BlogImage
  src="/claude-code-essentials-foundations/break-down.webp"
  caption="Break large tasks into phases, clear frequently, and be surgical with file references."
/>


Claude's context window maxes out at [200k tokens](https://support.claude.com/en/articles/8606394-how-large-is-the-context-window-on-paid-claude-plans). That seems generous until you're deep into a debugging session with accumulated error logs, and Claude's responses start becoming less precise about your specific setup.

### The problem with context pollution
- [Auto-compact](https://code.claude.com/docs/en/costs#reduce-token-usage) consumes significant tokens summarizing your conversation
- Long conversations accumulate error logs, permission prompts, and redundant information
- Using [MCP server](https://code.claude.com/docs/en/third-party-integrations#5-leverage-mcp-for-integrations) consumes tens of thousands of tokens per tool use
- Long conversations drift—Claude starts giving generic answers because it's drowning in your error logs

### Best practices for context management

1. **Use [`/clear`](https://code.claude.com/docs/en/slash-commands#built-in-slash-commands) frequently**

  I clear my conversation after every completed subtask. Once Claude has committed the code and tests pass, that context is done—carrying it forward just pollutes future conversations.

2. **Break large tasks into phases**

  <CodeBlock language="markdown" wrapLines={true} code={`
  Phase 1: "Review the authentication system and identify all endpoints"
  [Review results, then clear]

  Phase 2: "Add rate limiting to the login endpoint at /api/auth/login"
  [Implement, test, commit, then clear]

  Phase 3: "Add rate limiting to remaining auth endpoints..."
  `} />

3. **Be surgical with file references**

  - Instead "Look at everything in the `/components` folder"
  - Try: "Review `@components/AuthForm.tsx` and `@hooks/useAuth.ts`"

4. **Let Claude generate task breakdowns**

For complex work, have Claude create a checklist.

<CodeBlock language="markdown" wrapLines={true} code={`
"Generate a checklist of all files that need updating to migrate from
Redux to Zustand. For each file, describe the required changes."
`} />


5. **Use GitHub/GitLab CLI for tickets**

Then tackle each item in a focused conversation.

<CodeBlock language="markdown" code={`
"Generate 5 GitHub issues for this migration. Use the gh CLI to create them
with proper labels and link them to the epic."
`} />

### The guiding principle

Maximize the signal-to-noise ratio in Claude's context window. Keep conversations tight, focused, and relevant to the immediate task.

<div hidden={true}>

## What's Next

In **Part 2: Advanced Claude Code Workflows**, we'll explore power features that take your productivity to the next level:

- **Delegating to specialized sub-agents** for complex, focused tasks
- **Custom slash commands** for reusable workflows
- **The # key** for quick memory management
- **Custom hooks** to automate your development process

These foundations you've learned in Part 1 - specificity, CLAUDE.md, Plan Mode, and context management - are essential for making the most of the advanced features we'll cover next.

[Continue to Part 2 →](/blog/claude-code-advanced-workflows)

---
</div>

## Resources
- [Official Claude Code Documentation](https://code.claude.com/docs)
- [Claude Code Best Practices - Anthropic Engineering](https://www.anthropic.com/engineering/claude-code-best-practices)


export default function Page({ children }) {
  return (
    <MdxLayout metadata={metadata} slug={CLAUDE_CODE_ESSENTIALS_FOUNDATIONS.slug}>
      {children}
    </MdxLayout>
  )
}
